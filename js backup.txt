      
document.addEventListener('DOMContentLoaded', () => {
    // DOM Elements (selectors remain the same)
    const fileInput = document.getElementById('epubFile');
    const sourceTextArea = document.getElementById('source-text');
    const textDisplayArea = document.getElementById('text-display-area');
    const wpmDisplay = document.getElementById('wpm');
    const accuracyDisplay = document.getElementById('accuracy');
    const errorsDisplay = document.getElementById('errors');
    const bookProgressDisplay = document.getElementById('bookProgress');
    const prevChapterButton = document.getElementById('prevChapter');
    const nextChapterButton = document.getElementById('nextChapter');
    const chapterInfoDisplay = document.getElementById('chapterInfo');
    const hiddenInput = document.getElementById('hidden-input');
    const P_BREAK_PLACEHOLDER = '¶'; // Using Pilcrow symbol as placeholder

    // State Variables
    let book = null;
    let currentFilename = null; // Will be set by loadLastOpenedFilePreference
    let spineItems = [];
    let currentChapterIndex = 0; // Default starting point
    let currentChapterText = "";
    let currentTypedIndex = 0; // Default starting point
    let errors = 0;
    let totalTyped = 0;
    let startTime = null;
    let isLoading = false;
    let totalBookCharacters = 0;
    let chapterLengths = []; // Array of chapter lengths
    let bookLengthCalculated = false; // <<< Flag for caching
    let initialCharIndexToLoad = 0; // Dedicated var for loading progress
    // Chunking State
    const CHUNK_SIZE = 6; // Number of paragraphs per chunk
    let chapterChunks = []; // Array of paragraph arrays [[p1, p2,...], [p7, p8,...]]
    let currentChunkIndex = 0;
    let currentChunkText = ""; // The text content of the current chunk
    let currentTypedIndexInChunk = 0; // Typing index WITHIN the current chunk
    let chunkStartIndexInChapter = 0; // Character index where the current chunk starts in the ORIGINAL chapter text

    const LAST_OPENED_KEY = 'epubTyperLastOpenedFile';
    const PROGRESS_KEY_PREFIX = 'epubTyperProgress_'; // Includes progress AND cached length data

    // --- Initialization ---
    loadLastOpenedFilePreference(); // Sets currentFilename if available
    resetUI(); // Updates UI based *only* on currentFilename presence

    // --- Event Listeners ---
    fileInput.addEventListener('change', handleFileSelect);
    prevChapterButton.addEventListener('click', () => navigateChapter(-1));
    nextChapterButton.addEventListener('click', () => navigateChapter(1));
    document.addEventListener('keydown', handleKeyDown);
    sourceTextArea.addEventListener('click', () => hiddenInput.focus()); // Keep focus logic


    // --- Core Functions ---

    function loadLastOpenedFilePreference() {
        const lastFile = localStorage.getItem(LAST_OPENED_KEY);
        if (lastFile) {
            console.log("Previously opened file found:", lastFile);
            currentFilename = lastFile; // ONLY set the filename
        } else {
            currentFilename = null; // Ensure it's null if nothing is stored
        }
        // DO NOT call resetUI here. Let DOMContentLoaded handle it.
    }

    async function handleFileSelect(event) {
        const file = event.target.files[0];
        const expectedFilename = currentFilename; // Store the potentially pre-loaded filename from page load

        // Validation check using 'file'
        if (isLoading || !file || !file.name.endsWith('.epub')) {
           if (file && !file.name.endsWith('.epub')) { // Check if 'file' exists but is wrong type
               alert("Please select a valid .epub file.");
           } else if (!file) {
                console.log("No file selected."); // Handle case where no file is chosen after prompt
           }
           // If isLoading is true, log that too
           if (isLoading) {
               console.log("handleFileSelect: Aborted because isLoading is true.");
           }
           try { fileInput.value = ''; } catch(e) { console.warn("Couldn't clear file input");}
           return; // Exit if loading, no file, or wrong file type
        }

        // --- Check if selected file matches the expected one (if any) ---
        const selectedFilename = file.name;
        if (expectedFilename && selectedFilename !== expectedFilename) {
            console.log(`Selected file '${selectedFilename}' differs from expected '${expectedFilename}'. Resetting progress and state.`);
            // Clear progress associated with the OLD filename before proceeding
             clearProgress(expectedFilename); // Clear old progress
             resetState(true); // Full reset including filename, chapter index, etc.
             currentFilename = selectedFilename; // Set to the NEW selected filename
             // UI will be reset implicitly by loading the new file below
        } else {
             // Filename matches expected, or no specific file was expected
             currentFilename = selectedFilename; // Ensure it's set for the loading process
             // If filename matches, we only need a partial reset
             resetState(false); // Keep filename, reset typing/chapter state
        }
        // --- END Check ---


        console.log(`handleFileSelect: Starting for ${currentFilename}`);
        // resetState(false) was called above if filename matched

        console.log(`handleFileSelect: Setting isLoading = true`);
        setLoadingState(true, "Loading EPUB...");

        const reader = new FileReader();

        reader.onload = async (e) => {
            console.log(`handleFileSelect: reader.onload started.`);
            const arrayBuffer = e.target.result;
            try {
                book = ePub(arrayBuffer);
                await book.ready;
                await book.spine.ready;

                spineItems = book.spine.spineItems;
                if (!spineItems || !Array.isArray(spineItems) || spineItems.length === 0) {
                     throw new Error("EPUB spine data is invalid or empty.");
                }
                console.log(`handleFileSelect: Spine ready, found ${spineItems.length} items.`);

                // --- Load progress (for the confirmed currentFilename) ---
                // This ensures progress (including cached lengths) is loaded for the file being processed.
                loadProgress();
                console.log(`handleFileSelect: loadProgress finished. Target chapter index: ${currentChapterIndex}. Initial char index: ${initialCharIndexToLoad}`);

                // --- Calculate or Use Cached Book Length ---
                if (!bookLengthCalculated) {
                    console.log(`handleFileSelect: Calculating book length...`);
                    // Consider adding setLoadingState here if calculation is long
                    // setLoadingState(true, "Calculating book length...");
                    await calculateTotalBookCharacters(); // Calculates and sets bookLengthCalculated flag
                    console.log(`handleFileSelect: Book length calculation finished.`);
                    // If you added setLoadingState above, set it false here if needed,
                    // but the main setLoadingState(false) below should handle it.
                } else {
                    console.log("handleFileSelect: Using cached book length data.");
                    updateBookProgress(); // Update display with cached data now that spine is ready
                }

                // --- Save Preferences and Load Chapter ---
                localStorage.setItem(LAST_OPENED_KEY, currentFilename); // Save the *actually* loaded filename

                console.log(`handleFileSelect: Setting isLoading = false before calling loadChapter.`);
                setLoadingState(false);

                console.log(`handleFileSelect: isLoading is now ${isLoading}. Calling loadChapter(${currentChapterIndex}).`);
                await loadChapter(currentChapterIndex); // Load the target chapter

                console.log(`handleFileSelect: loadChapter call finished.`);
                // Save progress AFTER chapter load, which includes potential completion check
                saveProgress();

            } catch (err) {
                 console.error("handleFileSelect: Error processing EPUB:", err);
                 alert(`Could not load or parse the EPUB file: ${err.message || 'Unknown error'}`);
                 clearProgress(currentFilename); // Clear potentially corrupted progress
                 resetState(true); // Full reset on critical error
                 resetUI(); // Show initial prompt again
                 console.log(`handleFileSelect: Error catch - Setting isLoading = false`);
                 setLoadingState(false); // Ensure loading is off on error
            }
        };

        reader.onerror = () => {
            console.error("Error reading file.");
            alert('Error reading file.');
            resetState(true);
            resetUI();
            console.log(`handleFileSelect: reader.onerror - Setting isLoading = false`);
            setLoadingState(false); // Ensure it's off on reader error too
        };

        reader.readAsArrayBuffer(file);
    }


    // Calculates (if needed) AND updates state variables
    async function calculateTotalBookCharacters() {
        totalBookCharacters = 0;
        chapterLengths = new Array(spineItems.length).fill(0);
        console.log("Calculating total characters for all chapters...");
        bookLengthCalculated = false; // Start assuming calculation is needed

        try {
            for (let i = 0; i < spineItems.length; i++) {
                const section = spineItems[i];
                if (section && typeof section.load === 'function') {
                    const contents = await section.load(book.load.bind(book));
                    let bodyContent = '';
                    if (contents instanceof Document || contents instanceof Node) {
                        const bodyElement = contents.querySelector('body');
                        bodyContent = bodyElement ? bodyElement.innerHTML : contents.textContent || '';
                    } else if (typeof contents === 'string') {
                        bodyContent = contents;
                    }

                    // --- PRE-PROCESS HTML for Breaks ---
                    let processedHtml = bodyContent
                        .replace(/<\/p>/gi, '\n\n')
                        .replace(/<br\s*\/?>\s*<br\s*\/?>/gi, '\n\n')
                        .replace(/<p.*?>/gi, '\n') // Keep this for potential separation before processing
                        .replace(/<br.*?>/gi, '\n');
                    // --- END PRE-PROCESS ---

                    const tempDiv = document.createElement('div');
                    tempDiv.innerHTML = processedHtml;
                    let rawText = (tempDiv.textContent || '');
                    tempDiv.remove();

                          
            // --- NORMALIZE Text Content ---
                    rawText = rawText
                    .replace(/\r\n/g, '\n') // Standardize line endings
                    .replace(/ /g, ' ') // Handle non-breaking spaces

                    // *** Insert break BEFORE numbered headers ***
                    // BUT ensure it doesn't add a break if one was just placed by \n\n rule
                    // We'll clean up after.
                    // This regex remains the same for now:
                    .replace(/(\s|^)(\d+\.\d+)\s+([A-Z])/g, `$1${P_BREAK_PLACEHOLDER}$2 $3`)

                    // *** MODIFIED: Replace double newlines with placeholder ONLY ***
                    .replace(/\n{2,}/g, P_BREAK_PLACEHOLDER) // REMOVED surrounding spaces

                    // Handle remaining single newlines (convert to space)
                    .replace(/\n/g, ' ')

                    // Standard replacements
                    .replace(/—/g, '-')
                    .replace(/[“”]/g, '"')
                    .replace(/[‘’]/g, "'")

                    // *** Collapse multiple spaces ***
                    .replace(/\s+/g, ' ')

                    // *** Remove space immediately AFTER a placeholder ***
                    .replace(new RegExp(`${P_BREAK_PLACEHOLDER}\\s+`, 'g'), P_BREAK_PLACEHOLDER)

                    // *** NEW: Remove placeholder/space BEFORE a header pattern ***
                    // Matches a placeholder, optional space, then the digits.dots.digits pattern
                    // Replaces it with just the digits.dots.digits pattern
                    .replace(new RegExp(`[${P_BREAK_PLACEHOLDER}\\s]+\\s*(\\d+\\.\\d+)`, 'g'), '$1')

                    // *** Trim leading/trailing whitespace AND placeholders ***
                    .replace(new RegExp(`^[${P_BREAK_PLACEHOLDER}\\s]+|[${P_BREAK_PLACEHOLDER}\\s]+$`, 'g'), ''); // Custom trim
                // --- END NORMALIZE ---



                    // *** NEW: Remove space immediately AFTER a placeholder ***
                    // Example: "end sentence. ¶ Next sentence" -> "end sentence.¶Next sentence"
                    // This prevents the need to type a space at the start of a new paragraph.
                    rawText = rawText.replace(new RegExp(`${P_BREAK_PLACEHOLDER}\\s+`, 'g'), P_BREAK_PLACEHOLDER);


                    chapterLengths[i] = rawText.length;
                    totalBookCharacters += rawText.length;
                } else {
                    console.warn(`Skipping section ${i} during length calculation: Invalid section or load function.`);
                    chapterLengths[i] = 0; // Assign 0 length if skipped
                }
            }
            console.log(`Total calculated book characters: ${totalBookCharacters}`);
            bookLengthCalculated = true; // Mark calculation as complete
            updateBookProgress(); // Update display immediately after calculation

        } catch (error) {
            console.error("Error during total character calculation:", error);
            totalBookCharacters = 0; // Reset on error
            chapterLengths = [];
            bookLengthCalculated = false; // Ensure flag is false on error
            bookProgressDisplay.textContent = "Book: N/A";
        }
    }


          
          
          
    async function loadChapter(chapterIndex) {
        console.log(`loadChapter(${chapterIndex}): Function called.`);

        // Basic validation checks...
        if (!spineItems || spineItems.length === 0 || isLoading || chapterIndex < 0 || chapterIndex >= spineItems.length) {
        let reason = `chapterIndex=${chapterIndex}, spineLength=${spineItems?.length ?? 'N/A'}`;
        if (isLoading) reason += `, isLoading=true`;
        if (!spineItems || spineItems.length === 0) reason += `, no spineItems`;
        if (chapterIndex < 0) reason += `, chapterIndex < 0`;
        if (spineItems && chapterIndex >= spineItems.length) reason += `, chapterIndex >= spineLength`;
        console.warn(`loadChapter: Aborted entry validation. Reason(s): ${reason}`);
        if(isLoading) setLoadingState(false); // Turn off loading if aborting due to it
        return;
        }

        console.log(`loadChapter(${chapterIndex}): Passed entry validation. Setting isLoading = true.`);
        setLoadingState(true, `Loading Chapter ${chapterIndex + 1}...`);
        currentChapterIndex = chapterIndex; // Set the *actual* current chapter index
        let chapterSuccessfullyLoaded = false;

        try {
            // --- Retrieve saved starting index for THIS chapter ---
            let startingIndex = 0;
            const chapterProgressMap = window.currentBookChapterProgress || {};
            const savedCharIndex = chapterProgressMap[String(chapterIndex)]; // Use string key

            if (typeof savedCharIndex === 'number' && savedCharIndex >= 0) {
                startingIndex = savedCharIndex;
                console.log(`loadChapter(${chapterIndex}): Found saved progress index: ${startingIndex}`);
            } else {
                startingIndex = 0; // Default to start if no progress saved for this chapter
                console.log(`loadChapter(${chapterIndex}): No saved progress found for this chapter, starting at index 0.`);
            }
            // --- End Retrieve starting index ---


            const section = spineItems[currentChapterIndex];
            if (!section || typeof section.load !== 'function') {
                throw new Error(`Invalid spine section at index ${currentChapterIndex}.`);
            }

            // --- Load section content ---
            const contents = await section.load(book.load.bind(book));
            console.log(`loadChapter(${chapterIndex}): Section content loaded.`);
            let bodyContent = '';
            if (contents instanceof Document || contents instanceof Node) {
                const bodyElement = contents.querySelector('body');
                bodyContent = bodyElement ? bodyElement.innerHTML : contents.textContent || '';
            } else if (typeof contents === 'string') {
                bodyContent = contents;
            }

            // --- PRE-PROCESS HTML --- (Normalization logic remains the same)
            let processedHtml = bodyContent
                .replace(/<\/p>/gi, '\n\n')
                .replace(/<br\s*\/?>\s*<br\s*\/?>/gi, '\n\n')
                .replace(/<p.*?>/gi, '\n')
                .replace(/<br.*?>/gi, '\n');
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = processedHtml;
            let rawText = (tempDiv.textContent || '');
            tempDiv.remove();

            // --- NORMALIZE Text Content --- (Remains the same as previous version)
            rawText = rawText
                .replace(/\r\n/g, '\n') // Standardize line endings
                .replace(/ /g, ' ') // Handle non-breaking spaces
                .replace(/(\s|^)(\d+\.\d+)\s+([A-Z])/g, `$1${P_BREAK_PLACEHOLDER}$2 $3`) // Headers
                .replace(/\n{2,}/g, P_BREAK_PLACEHOLDER) // Double newlines
                .replace(/\n/g, ' ') // Single newlines
                .replace(/—/g, '-')
                .replace(/[“”]/g, '"')
                .replace(/[‘’]/g, "'")
                .replace(/\s+/g, ' ') // Collapse spaces
                .replace(new RegExp(`${P_BREAK_PLACEHOLDER}\\s+`, 'g'), P_BREAK_PLACEHOLDER) // Space after break
                .replace(new RegExp(`[${P_BREAK_PLACEHOLDER}\\s]+\\s*(\\d+\\.\\d+)`, 'g'), '$1') // Break/space before header
                .replace(new RegExp(`^[${P_BREAK_PLACEHOLDER}\\s]+|[${P_BREAK_PLACEHOLDER}\\s]+$`, 'g'), ''); // Trim breaks/spaces
            // --- END NORMALIZE ---

        currentChapterText = rawText;

            // --- Optional: Validate/Update Chapter Length Cache ---
            // (This logic can remain the same as previous version)
            if (bookLengthCalculated && chapterLengths.length > chapterIndex) {
                if (chapterLengths[chapterIndex] !== currentChapterText.length) {
                    console.warn(`loadChapter: Updating chapter length cache for index ${chapterIndex}. Old: ${chapterLengths[chapterIndex]}, New: ${currentChapterText.length}.`);
                    chapterLengths[chapterIndex] = currentChapterText.length;
                    totalBookCharacters = chapterLengths.reduce((sum, len) => sum + (len || 0), 0);
                    console.log(`Total book characters updated to: ${totalBookCharacters}`);
                    // Also update the saved bookLengthData if it exists
                    const key = PROGRESS_KEY_PREFIX + currentFilename;
                    const savedData = localStorage.getItem(key);
                    if(savedData) {
                        try {
                            let progressData = JSON.parse(savedData);
                            if(progressData.bookLengthData) {
                                progressData.bookLengthData.totalChars = totalBookCharacters;
                                progressData.bookLengthData.chapLengths = chapterLengths;
                                localStorage.setItem(key, JSON.stringify(progressData));
                                console.log("Updated bookLengthData in localStorage");
                            }
                        } catch(e) { console.error("Failed to update bookLengthData in storage", e); }
                    }
                }
            } else if (bookLengthCalculated) {
                console.warn("Book length was calculated, but chapterLengths array seems inconsistent.");
            }
            // --- End Chapter length caching/validation ---

            console.log(`loadChapter(${chapterIndex}): Text processed. Length: ${currentChapterText.length} chars.`);

            displayChapterText(); // Renders the spans FIRST
            resetTypingStateForNewChapter(); // Resets errors, startTime, totalTyped

            // --- Set current typing index ---
            // Clamp startingIndex to valid range [0, length]
            currentTypedIndex = Math.max(0, Math.min(startingIndex, currentChapterText.length));
            console.log(`loadChapter(${chapterIndex}): Setting currentTypedIndex to ${currentTypedIndex} (from saved/default ${startingIndex})`);

            // --- Restore Visual State ---
            console.log(`loadChapter: Restoring visual state up to index ${currentTypedIndex}`);
            for (let i = 0; i < currentTypedIndex; i++) {
                if (currentChapterText[i] !== P_BREAK_PLACEHOLDER) {
                    const charSpan = document.getElementById(`char-${i}`);
                    if (charSpan) {
                        // Mark as correct - we don't restore incorrect state currently
                        charSpan.classList.remove('incorrect', 'current', 'needs-enter');
                        charSpan.classList.add('correct');
                    }
                }
            }
            // Check if the character *just before* the current index requires 'needs-enter'
            if (currentTypedIndex > 0 && currentTypedIndex <= currentChapterText.length) {
                const nextCharIsBreak = currentChapterText[currentTypedIndex] === P_BREAK_PLACEHOLDER;
                const prevCharSpan = document.getElementById(`char-${currentTypedIndex - 1}`);
                if (nextCharIsBreak && prevCharSpan) {
                    prevCharSpan.classList.add('needs-enter');
                    console.log(`loadChapter: Restored needs-enter state for index ${currentTypedIndex - 1}`);
                }
            }
            // --- End Restore Visual State ---


            // --- Handle Completion State (Visual Only Here) ---
            if (currentTypedIndex >= currentChapterText.length && currentChapterText.length > 0) {
                console.log(`loadChapter: Chapter ${chapterIndex + 1} is marked as completed based on index.`);
                markChapterAsCompletedUI(); // Ensure fully correct style if loaded at/past end
            } else if (currentChapterText.length === 0) {
                console.log(`loadChapter: Chapter ${chapterIndex + 1} is empty.`);
                markChapterAsCompletedUI(); // Style empty as 'complete'
            }


            // Update UI elements
            updateStats(); // Update stats display (will be 0 initially)
            updateNavigation();
            updateBookProgress(); // Reflects potentially loaded progress
            updateCursor(); // Position cursor correctly

            // Save progress immediately after loading to capture the initial state if needed?
            // Maybe not necessary, saveProgress happens on keydown/navigation.

            chapterSuccessfullyLoaded = true;
            console.log(`loadChapter(${chapterIndex}): Chapter processing complete, UI updated.`);

    } catch (err) {
        console.error(`loadChapter(${chapterIndex}): Error during chapter processing:`, err);
        sourceTextArea.innerHTML = `<p style="color: red;">Error loading chapter ${currentChapterIndex + 1}: ${err.message}</p>`;
        resetTypingStateForNewChapter(); // Reset stats
        updateNavigation();
        updateBookProgress(); // Update progress display
        chapterSuccessfullyLoaded = false;
    } finally {
        console.log(`loadChapter(${chapterIndex}): Finally block - Setting isLoading = false.`);
        setLoadingState(false); // Ensure loading is off
        // Focus input only if successfully loaded and chapter has content to type
        if (chapterSuccessfullyLoaded && currentTypedIndex < currentChapterText.length) {
                try { hiddenInput.focus(); } catch(e) { console.warn("Could not focus hidden input:", e); }
        }
    }
    } // End loadChapter





    
    function displayChapterText() {
        if (currentChapterText == null) {
             sourceTextArea.innerHTML = "<p style='color: red;'>Error: Chapter text unavailable.</p>";
             return;
         }

        // --- MODIFIED SPAN MAPPING ---
        const htmlContent = currentChapterText
            .split('')
            .map((char, index) => {
                if (char === P_BREAK_PLACEHOLDER) {
                    // Output double line breaks for the placeholder
                    return '<br><br>';
                } else {
                    // Output regular span for other characters
                    // Use non-breaking space for display to ensure spacing is visible
                    const displayChar = char === ' ' ? ' ' : char;
                    return `<span id="char-${index}">${displayChar}</span>`;
                }
            })
            .join('');
        // --- END MODIFIED SPAN MAPPING ---

        sourceTextArea.innerHTML = htmlContent;

        console.log("Chapter text rendered with paragraph breaks.");

        if (currentChapterText.length === 0 || sourceTextArea.innerHTML === '') { // Check if result is empty
             sourceTextArea.innerHTML = "<p>(Chapter appears empty)</p>";
        } else {
            // Cursor update will happen in loadChapter after potential index is applied
        }

         try {
            hiddenInput.focus();
         } catch (e) {
             console.warn("Could not focus hidden input:", e);
         }
    }

    // handleKeyDown remains largely the same as the previous version
    // (with Ctrl+Backspace, regular backspace, character typing logic)
          
          
          
          
    function handleKeyDown(event) {
        // Initial checks (loading, chapter loaded?)
        if (isLoading || !currentChapterText) { return; }

        // Allow backspace even if technically "finished"
        if (currentTypedIndex >= currentChapterText.length && event.key !== 'Backspace') {
            // Allow Enter/Space if the very last character is a placeholder we are waiting on
            if(!(currentTypedIndex === currentChapterText.length &&
                currentTypedIndex > 0 &&
                currentChapterText[currentTypedIndex-1] === P_BREAK_PLACEHOLDER &&
                (event.key === 'Enter' || event.key === ' ')) )
            {
                return;
            }
            // If we are exactly at the end AND the last char was a break, allow Enter/Space to "finish" conceptually
            // This edge case shouldn't really happen with current logic but is safe.
        }


        const key = event.key;
        const isCtrlBackspace = event.ctrlKey && key === 'Backspace';

        // --- Prevent Default Actions ---
        if (key === ' ' || key === 'Backspace' || key === 'Enter') {
            event.preventDefault();
        }

        // Ignore non-typing keys unless handled
        if (key.length > 1 && key !== 'Backspace' && key !== 'Enter' && !isCtrlBackspace) {
            return;
        }

        // --- Handle Backspace (Single and Ctrl) ---
        if (key === 'Backspace') {
            event.preventDefault();
            const indexToClear = currentTypedIndex - 1; // Index of char potentially being cleared

            if (isCtrlBackspace) {
                // Ctrl+Backspace Logic
                if (currentTypedIndex === 0) return;
                const originalIndex = currentTypedIndex;
                let targetIndex = currentTypedIndex - 1;
                // Skip trailing spaces/placeholders
                while (targetIndex >= 0 && (currentChapterText[targetIndex] === P_BREAK_PLACEHOLDER || /\s/.test(currentChapterText[targetIndex]))) { targetIndex--; }
                // Find start of word/break
                while (targetIndex >= 0 && currentChapterText[targetIndex] !== P_BREAK_PLACEHOLDER && !/\s/.test(currentChapterText[targetIndex])) { targetIndex--; }
                const newIndex = targetIndex + 1; // Land after the space/break/start

                // Clear styles between newIndex and originalIndex
                for (let i = newIndex; i < originalIndex; i++) {
                    if (currentChapterText[i] === P_BREAK_PLACEHOLDER) continue; // Skip placeholder itself
                    const charSpan = document.getElementById(`char-${i}`);
                    if (charSpan) {
                        if (charSpan.classList.contains('incorrect')) { errors = Math.max(0, errors - 1); }
                        // Remove all relevant classes
                        charSpan.classList.remove('correct', 'incorrect', 'current', 'needs-enter');
                    }
                }
                currentTypedIndex = newIndex;

            } else {
                // Regular Backspace Logic
                if (currentTypedIndex > 0) {
                    currentTypedIndex--; // Move index back first

                    // If we landed on a placeholder, skip backwards past it
                    while (currentTypedIndex >= 0 && currentChapterText[currentTypedIndex] === P_BREAK_PLACEHOLDER) {
                        console.log(`Backspace skipping placeholder at index ${currentTypedIndex}`);
                        currentTypedIndex--;
                    }
                    // If we went past index 0, reset to 0
                    if (currentTypedIndex < 0) currentTypedIndex = 0;


                    // Clean style of the character span we just backspaced *from* (indexToClear)
                    // This handles the visual removal of correct/incorrect status
                    if (indexToClear >= 0 && currentChapterText[indexToClear] !== P_BREAK_PLACEHOLDER) {
                        const charSpan = document.getElementById(`char-${indexToClear}`);
                        if (charSpan) {
                            if (charSpan.classList.contains('incorrect')) { errors = Math.max(0, errors - 1); }
                            charSpan.classList.remove('correct', 'incorrect', 'current', 'needs-enter');
                        }
                    }

                    // Reset timer if backspacing to the very beginning
                    if (currentTypedIndex === 0 && totalTyped <= 1) { // Check totalTyped as well
                        startTime = null;
                        totalTyped = 0; // Reset total typed if timer resets
                        console.log("Timer reset due to backspace to start.");
                    }
                }
            }

            // --- Cleanup 'needs-enter' from the character potentially *before* the new cursor position ---
            // This handles cases like: Correct<needs-enter> ¶ -> Backspace -> Correct ¶ (remove needs-enter)
            if (currentTypedIndex > 0 && currentTypedIndex < currentChapterText.length && currentChapterText[currentTypedIndex] !== P_BREAK_PLACEHOLDER) {
                // Check the character *before* the new cursor position
                const spanBeforeCursor = document.getElementById(`char-${currentTypedIndex - 1}`);
                if(spanBeforeCursor && spanBeforeCursor.classList.contains('needs-enter')) {
                    spanBeforeCursor.classList.remove('needs-enter');
                    console.log(`Removed needs-enter from index ${currentTypedIndex - 1} after backspace`);
                }
            }


            // Update UI after backspace
            updateCursor(); // Update cursor position and scroll
            updateStats(); // Update WPM/Acc/Errors
            updateBookProgress(); // Update book percentage
            saveProgress(); // Save new position
            return; // Stop processing after backspace
        } // End Backspace Handling


        // --- Handle Typing / Enter / Space Key ---

        // Check if the current position IS a break point
        const expectedChar = currentChapterText[currentTypedIndex];
        const isBreakPoint = (expectedChar === P_BREAK_PLACEHOLDER);

        // --- Case 1: AT a Paragraph Break ---
        if (isBreakPoint) {
            if (key === 'Enter' || key === ' ') {
                // CORRECT ACTION: Advance past the break
                console.log(`Key '${key}' pressed correctly at paragraph break.`);

                // Find the span *before* the break (if it exists) to clear potential error styles AND 'needs-enter'
                const precedingSpanIndex = currentTypedIndex - 1;
                if (precedingSpanIndex >= 0) {
                    const precedingSpan = document.getElementById(`char-${precedingSpanIndex}`);
                    if (precedingSpan) {
                        precedingSpan.classList.remove('incorrect', 'needs-enter'); // Remove both
                        // Ensure it's marked correct if it wasn't already
                        if(!precedingSpan.classList.contains('correct')) {
                            precedingSpan.classList.add('correct');
                        }
                    }
                }

                // Advance cursor index PAST the placeholder
                currentTypedIndex++;

                // Skip any *additional* consecutive placeholders (defensive)
                while (currentTypedIndex < currentChapterText.length && currentChapterText[currentTypedIndex] === P_BREAK_PLACEHOLDER) {
                    console.warn("Skipping consecutive placeholder during Enter/Space advance.");
                    currentTypedIndex++;
                }

                // Start timer if it hasn't started (e.g., chapter starts with break)
                if (!startTime && totalTyped === 0) { // Use totalTyped check
                    startTime = new Date();
                    console.log("Timer started on Enter/Space at initial break.");
                }

                // Update UI and State
                updateCursor(); // Move cursor past the break visually
                updateStats(); // Update stats (though not much changes here)
                updateBookProgress();
                saveProgress(); // Save the new position
                return; // ★★★ Stop processing here for correct Enter/Space ★★★

            } else {
                // INCORRECT ACTION at Break Point (pressed key other than Enter or Space)
                console.log(`Incorrect key '${key}' pressed at paragraph break (index ${currentTypedIndex}). Enter or Space required.`);

                // Style the character *before* the break as incorrect/needs-enter
                const precedingSpanIndex = currentTypedIndex - 1;
                if (precedingSpanIndex >= 0) {
                    const precedingSpan = document.getElementById(`char-${precedingSpanIndex}`);
                    if (precedingSpan) {
                        // Only increment error ONCE per incorrect attempt at the break point
                        if (!precedingSpan.classList.contains('incorrect')) {
                            errors++; // Increment error count
                            precedingSpan.classList.add('incorrect'); // Mark preceding char as incorrect
                            precedingSpan.classList.remove('correct'); // Ensure correct class removed
                            updateStats(); // Update error display immediately
                            console.log(`Error added for wrong key at break. Total errors: ${errors}`);
                        }
                        precedingSpan.classList.add('needs-enter'); // Ensure cue remains
                    } else {
                        console.warn("Couldn't find preceding span to mark as incorrect at break.");
                    }
                } else {
                    console.warn("At break point index 0, cannot mark preceding char incorrect.");
                }

                // DO NOT ADVANCE CURSOR
                return; // ★★★ Stop processing here for incorrect key at break ★★★
            }
        } // End Break Point Handling (isBreakPoint === true)

        // --- Case 2: NOT at a break point ---

        // Ignore Enter key if not at a break point
        if (key === 'Enter') {
            console.log("Enter key pressed - ignored when not at a break point.");
            return;
        }

        // Handle regular character typing (includes Space ' ' when not at a break point)
        if (key.length === 1) {
            const typedChar = key;
            const charSpan = document.getElementById(`char-${currentTypedIndex}`);
            if (!charSpan) { console.error(`Span not found: index ${currentTypedIndex}`); return; }

            // Start timer on first valid character typed
            if (!startTime) {
                startTime = new Date();
                console.log("Timer started on first character typed.");
            }

            // Check correctness
            const isExpectedSpace = (expectedChar === ' ' || expectedChar === '\u00A0');
            const isTypedSpace = (typedChar === ' ');
            let correct = false;

            if ((isTypedSpace && isExpectedSpace) || (!isExpectedSpace && typedChar === expectedChar)) {
                correct = true;
                charSpan.classList.add('correct');
                charSpan.classList.remove('incorrect', 'current', 'needs-enter');
            } else {
                correct = false;
                if (!charSpan.classList.contains('incorrect')) {
                    errors++;
                    console.log(`Error added for mismatch. Typed: '${typedChar}', Expected: '${expectedChar}'. Total errors: ${errors}`);
                }
                charSpan.classList.add('incorrect');
                charSpan.classList.remove('correct', 'current', 'needs-enter');
            }

            // Increment total typed count
            totalTyped++;

            // Store the index of the character span just styled
            const processedCharIndex = currentTypedIndex;

            // Increment cursor index AFTER processing current character
            currentTypedIndex++;

            // *** REVISED LOGIC: Check for break IMMEDIATELY after incrementing index ***
            let nowAtBreak = (currentTypedIndex < currentChapterText.length && currentChapterText[currentTypedIndex] === P_BREAK_PLACEHOLDER);

            if (nowAtBreak) {
                // We landed exactly on a break point. Apply 'needs-enter' and STOP.
                console.log(`Landed on break point at index ${currentTypedIndex} after typing.`);
                const spanToMark = document.getElementById(`char-${processedCharIndex}`);
                if (spanToMark) {
                    // Only add needs-enter if the typed char was correct
                    if(correct) {
                        spanToMark.classList.add('needs-enter');
                        console.log(`Marked char index ${processedCharIndex} as needs-enter.`);
                    } else {
                        // If incorrect, ensure 'needs-enter' is NOT present
                        spanToMark.classList.remove('needs-enter');
                        console.log(`Typed char at ${processedCharIndex} was incorrect, not adding needs-enter.`);
                    }
                } else {
                    console.warn(`Could not find span at index ${processedCharIndex} to mark needs-enter.`);
                }

                // Update stats and progress, save, but DO NOT update cursor or skip further
                updateStats();
                updateBookProgress();
                saveProgress();
                // Update cursor to sit ON the incorrect char or AFTER the correct char, before the break visually
                updateCursor(); // This will position the cursor *after* the processed char
                return; // ★★★ STOP HERE - Wait for user Enter/Space ★★★

            } else {
                // We did NOT land directly on a break point.
                // Now, we can safely skip any subsequent placeholders if they exist (e.g., char¶¶next)
                // This typically shouldn't happen with current normalization, but is safe to keep.
                while (currentTypedIndex < currentChapterText.length && currentChapterText[currentTypedIndex] === P_BREAK_PLACEHOLDER) {
                    console.log(`Skipping non-immediate placeholder at index ${currentTypedIndex} after typing.`);
                    currentTypedIndex++;
                }

                // Update UI fully since we are not waiting for Enter/Space
                updateCursor(); // Update cursor position and scroll
                updateStats();
                updateBookProgress();
                saveProgress(); // Save progress

                // Check if chapter finished
                if (currentTypedIndex >= currentChapterText.length) {
                    console.log(`Finished chapter ${currentChapterIndex + 1}`);
                    markChapterAsCompletedUI(); // Apply UI styling for completion
                    updateBookProgress(); // Ensure final update
                    saveProgress(); // Save the completed state immediately (currentTypedIndex will be >= length)
                }
                return; // Handled regular typing (not ending on a break)
            }
            // *** END REVISED LOGIC ***

        } // End Regular Character Handling

        // If code reaches here, it's an unhandled key
        console.log("Ignoring unhandled key:", key);
    } // End handleKeyDown



    function navigateChapter(direction) {
        if (isLoading || !spineItems || spineItems.length === 0) return;
        const newIndex = currentChapterIndex + direction;
        if (newIndex >= 0 && newIndex < spineItems.length) {
            initialCharIndexToLoad = 0; // Reset char index when navigating chapters
            loadChapter(newIndex);
        }
    }

    // --- Utility Functions ---

    function updateCursor() {
        const previousChar = sourceTextArea.querySelector('span.current');
        if (previousChar) previousChar.classList.remove('current');

         // Check if current index points to a placeholder - cursor should be positioned visually *after* it
         let effectiveIndex = currentTypedIndex;
         // This loop should ideally NOT be needed if handleKeyDown skips correctly, but as a safeguard:
          while (effectiveIndex < currentChapterText.length && currentChapterText[effectiveIndex] === P_BREAK_PLACEHOLDER) {
              effectiveIndex++;
          }


        if (currentChapterText && effectiveIndex < currentChapterText.length) {
            const currentCharSpan = document.getElementById(`char-${effectiveIndex}`); // Use effectiveIndex
            if (currentCharSpan) {
                currentCharSpan.classList.add('current');

                // Center Scrolling Logic (remains the same)
                try {
                    const spanTop = currentCharSpan.offsetTop;
                    const areaHeight = textDisplayArea.clientHeight;
                    const spanHeight = currentCharSpan.offsetHeight;
                    const targetScrollTop = spanTop - (areaHeight / 2) + (spanHeight / 2);
                    textDisplayArea.scrollTo({ top: Math.max(0, targetScrollTop), behavior: 'smooth' });
                } catch (e) { console.warn("Center scrolling failed:", e); /* Fallback */ }

            } else {
                // It's possible effectiveIndex points beyond last *rendered* span if text ends with placeholder(s)
                console.warn(`updateCursor: Span not found for effective index ${effectiveIndex}. (currentTypedIndex: ${currentTypedIndex})`);
                // If near end, just scroll down
                 if (currentTypedIndex >= currentChapterText.length - 5) { // Heuristic
                     textDisplayArea.scrollTop = textDisplayArea.scrollHeight;
                 }
            }
        } else if (currentChapterText && currentTypedIndex >= currentChapterText.length) {
            // End of text reached
            console.log("updateCursor: End of text.");
            textDisplayArea.scrollTop = textDisplayArea.scrollHeight; // Scroll to bottom
        }
    }

    // updateStats remains the same
    function updateStats() {
        const currentTime = new Date();
        const timeElapsed = (startTime && startTime instanceof Date) ? (currentTime - startTime) / 1000 / 60 : 0; // Minutes
        let currentWpm = 0;
         if (timeElapsed > 0 && totalTyped > 0) {
             const grossWords = (totalTyped / 5);
             currentWpm = Math.round(grossWords / timeElapsed);
             currentWpm = Math.max(0, currentWpm);
         }
        const correctlyTyped = Math.max(0, totalTyped - errors);
        const accuracy = totalTyped > 0 ? Math.round((correctlyTyped / totalTyped) * 100) : 100;

        wpmDisplay.textContent = `WPM: ${currentWpm}`;
        accuracyDisplay.textContent = `Acc: ${accuracy}%`; // Abbreviated label
        errorsDisplay.textContent = `Errors: ${errors}`;
    }

    // updateBookProgress remains the same
    function updateBookProgress() {
        // Use cached/calculated chapterLengths and totalBookCharacters
        if (!bookLengthCalculated || !Array.isArray(chapterLengths) || chapterLengths.length === 0 || !spineItems || chapterLengths.length !== spineItems.length) {
            bookProgressDisplay.textContent = "Book: N/A";
            return;
        }

        // --- Calculate Total Words ---
        // Only calculate if totalBookCharacters is positive to avoid division by zero later
        const totalBookWords = totalBookCharacters > 0 ? Math.max(1, Math.floor(totalBookCharacters / 5)) : 0; // Use standard 5 chars/word, ensure at least 1 if chars > 0

        // --- Calculate Completed Characters ---
        let charsInCompletedChapters = 0;
        for (let i = 0; i < currentChapterIndex; i++) {
            charsInCompletedChapters += (chapterLengths[i] || 0);
        }

        // Ensure current chapter index is valid
        if (currentChapterIndex < 0 || currentChapterIndex >= chapterLengths.length) {
             console.warn(`updateBookProgress: currentChapterIndex ${currentChapterIndex} is out of bounds.`);
             bookProgressDisplay.textContent = "Book: Error";
             return;
        }

        // Get progress within the current chapter (clamp to length)
        const currentChapterLen = chapterLengths[currentChapterIndex] || 0;
        let progressInCurrentChapterChars = Math.min(Math.max(0, currentTypedIndex), currentChapterLen);

        // Adjust if waiting for 'Enter' - progress hasn't passed the break
        if(currentTypedIndex > 0) {
            const precedingSpan = document.getElementById(`char-${currentTypedIndex - 1}`);
            if (precedingSpan && precedingSpan.classList.contains('needs-enter')) {
                progressInCurrentChapterChars = Math.max(0, currentTypedIndex - 1);
            }
        }

        const currentPositionInBookChars = charsInCompletedChapters + progressInCurrentChapterChars;

        // --- Calculate Completed Words ---
        const completedWords = totalBookCharacters > 0 ? Math.floor(currentPositionInBookChars / 5) : 0;

        // --- Calculate Percentage ---
        const percentage = totalBookWords > 0 ? Math.round((completedWords / totalBookWords) * 100) : 0;

        // --- Update Display ---
        // Showing percentage based on words, could also show completedWords / totalBookWords
        bookProgressDisplay.textContent = `Book: ${percentage}%`;
        // console.log(`Book Progress: ${completedWords} / ${totalBookWords} words (${percentage}%) - Chars: ${currentPositionInBookChars}/${totalBookCharacters}`);
    }


     function updateNavigation() {
        const hasChapters = spineItems && Array.isArray(spineItems) && spineItems.length > 0;
        if (hasChapters) {
            chapterInfoDisplay.textContent = `Ch: ${currentChapterIndex + 1}/${spineItems.length}`; // Shorter label
            prevChapterButton.disabled = isLoading || currentChapterIndex <= 0;
            nextChapterButton.disabled = isLoading || currentChapterIndex >= spineItems.length - 1;
        } else {
            chapterInfoDisplay.textContent = "Chapter: - / -";
            prevChapterButton.disabled = true;
            nextChapterButton.disabled = true;
        }
    }

     function setLoadingState(loading, message = "") {
        isLoading = loading;
        // Simple visual cue - maybe disable buttons is enough
         updateNavigation();
        // Optional: Add body class for more global styling
        document.body.classList.toggle('is-loading', loading);
        if (loading && !sourceTextArea.querySelector('span')) {
             sourceTextArea.innerHTML = `<p>${message || 'Loading...'}</p>`;
        }
     }


     function resetUI() {
        // Reset visual elements to defaults
        chapterInfoDisplay.textContent = "Chapter: - / -";
        bookProgressDisplay.textContent = "Book: 0%";
        prevChapterButton.disabled = true;
        nextChapterButton.disabled = true;
        resetStats(); // Reset WPM, Acc, Errors display

        // Update placeholder based ONLY on whether a previous file is known
        // currentFilename is set by loadLastOpenedFilePreference before this runs
        if (currentFilename) {
             // A filename exists - prompt user to re-select it
             sourceTextArea.innerHTML = `<p>Please re-select '<strong>${currentFilename}</strong>' to resume typing,<br>or choose a different EPUB file.</p>`;
        } else {
            // No filename known, show default prompt
             sourceTextArea.innerHTML = "<p>Please select an EPUB file to begin.</p>";
        }
        // DO NOT call loadProgress here. Progress is loaded ONLY in handleFileSelect.
        // Ensure navigation reflects the initial state (no chapter loaded yet)
        updateNavigation(); // Will disable buttons as spineItems is empty
   }

     function resetStats() {
         wpmDisplay.textContent = `WPM: 0`;
         accuracyDisplay.textContent = `Acc: 100%`; // Abbreviated
         errorsDisplay.textContent = `Errors: 0`;
     }

     function resetTypingStateForNewChapter() {
         // currentTypedIndex is set in loadChapter after this
         errors = 0;
         totalTyped = 0;
         startTime = null;
         initialCharIndexToLoad = 0;
         resetStats();
         console.log("Typing state reset for new chapter.");
     }

    function resetState(clearFileRelated = false) {
         book = null;
         spineItems = [];
         currentChapterIndex = 0;
         currentChapterText = "";
         totalBookCharacters = 0;
         chapterLengths = [];
         bookLengthCalculated = false; // <<< Reset cache flag

        resetTypingStateForNewChapter();

         if (clearFileRelated) {
             currentFilename = null;
             try { fileInput.value = ''; } catch (e) { /* ignore */ }
             // Don't clear LAST_OPENED_KEY automatically
             resetUI(); // Resets display fully
             sourceTextArea.innerHTML = "<p>Please select an EPUB file to begin.</p>";
         } else {
             // If keeping file, just update UI elements based on reset data
             updateNavigation();
             updateBookProgress();
         }
        console.log(`State reset invoked. Clear file related: ${clearFileRelated}`);
    }


    // --- Persistence (LocalStorage) ---

    function saveProgress() {
        if (!currentFilename || !spineItems || spineItems.length === 0) {
            return; // No file or structure loaded
        }

        const key = PROGRESS_KEY_PREFIX + currentFilename;
        let progressData = {};

        // Try to load existing data first to merge
        try {
            const existingData = localStorage.getItem(key);
            if (existingData) {
                progressData = JSON.parse(existingData);
            }
        } catch (e) {
            console.error("Error parsing existing progress data before saving:", e);
            // Start fresh if parsing fails
            progressData = {};
        }

        // Ensure chapterProgress object exists
        if (!progressData.chapterProgress) {
            progressData.chapterProgress = {};
        }

        // Update the character index for the CURRENT chapter
        // Store chapter index as string key (JSON compatibility)
        progressData.chapterProgress[String(currentChapterIndex)] = currentTypedIndex;
        console.log(`saveProgress: Updating chapter ${currentChapterIndex} to index ${currentTypedIndex}`);

        // Keep existing book length data if present
        if (bookLengthCalculated && !progressData.bookLengthData) {
             progressData.bookLengthData = {
                 totalChars: totalBookCharacters,
                 chapLengths: chapterLengths
             };
             console.log(`saveProgress: Adding bookLengthData to saved progress.`);
        } else if (bookLengthCalculated && progressData.bookLengthData) {
             // Optionally update if recalculated, though usually done once
             progressData.bookLengthData.totalChars = totalBookCharacters;
             progressData.bookLengthData.chapLengths = chapterLengths;
        }


        // Save the updated progress object
        try {
            localStorage.setItem(key, JSON.stringify(progressData));
             // console.log(`Progress saved for ${currentFilename}:`, progressData);
        } catch (e) {
            console.error("Error saving progress:", e);
        }
    }

    function loadProgress() {
        // Reset state vars related to progress cache before loading
        totalBookCharacters = 0;
        chapterLengths = [];
        bookLengthCalculated = false; // Assume not loaded initially
        // Clear any previously loaded global chapter progress map if needed
        // (We'll load it fresh below if available)
        window.currentBookChapterProgress = {}; // Use a distinct global/window object

        // Ensure filename and spine are ready
        if (!currentFilename || !spineItems || spineItems.length === 0) {
            console.log("loadProgress SKIPPED: No filename or spineItems not ready.");
            return;
        }

        const key = PROGRESS_KEY_PREFIX + currentFilename;
        const savedData = localStorage.getItem(key);
        console.log(`loadProgress: Attempting to load book data for key: ${key}`);

        if (savedData) {
            try {
                const progressData = JSON.parse(savedData);
                console.log(`loadProgress: Found saved data:`, progressData);

                // --- Validate and load cached book length data ---
                if (progressData.bookLengthData &&
                    typeof progressData.bookLengthData.totalChars === 'number' &&
                    progressData.bookLengthData.totalChars >= 0 && // Allow 0 total chars
                    Array.isArray(progressData.bookLengthData.chapLengths) &&
                    progressData.bookLengthData.chapLengths.length === spineItems.length)
                {
                    totalBookCharacters = progressData.bookLengthData.totalChars;
                    chapterLengths = progressData.bookLengthData.chapLengths;
                    bookLengthCalculated = true; // Mark as loaded from cache
                    console.log(`loadProgress: Cached book length loaded: ${totalBookCharacters} chars, ${chapterLengths.length} chapters.`);
                } else {
                     console.log("loadProgress: Cached book length data not found or invalid.");
                     bookLengthCalculated = false; // Ensure flag is false if data is bad
                }

                // --- Load chapter progress map ---
                if (progressData.chapterProgress && typeof progressData.chapterProgress === 'object') {
                    window.currentBookChapterProgress = progressData.chapterProgress;
                    console.log(`loadProgress: Loaded chapter progress map:`, window.currentBookChapterProgress);
                } else {
                    console.log("loadProgress: No chapter progress map found in saved data.");
                    window.currentBookChapterProgress = {}; // Initialize empty map
                }

            } catch (e) {
                console.error("loadProgress: Error parsing saved progress:", e);
                // Reset everything if parsing fails
                totalBookCharacters = 0;
                chapterLengths = [];
                bookLengthCalculated = false;
                window.currentBookChapterProgress = {};
                // Optionally clear corrupted data?
                // clearProgress();
            }
        } else {
            console.log(`loadProgress: No saved progress found for ${currentFilename}. Starting fresh.`);
            // Ensure state is default if no progress found
            bookLengthCalculated = false;
            window.currentBookChapterProgress = {};
        }
         // Do NOT set global currentChapterIndex or initialCharIndexToLoad here.
         // updateNavigation/BookProgress are called later
    }


    function clearProgress(filename = currentFilename) {
        if (!filename) return;
        const key = PROGRESS_KEY_PREFIX + filename;
        try {
            localStorage.removeItem(key);
            console.log(`Cleared saved progress for ${filename}`);
        } catch (e) { console.error("Error removing progress from localStorage:", e); }
    }

    function markChapterAsCompletedUI() {
        console.log(`Marking Chapter ${currentChapterIndex + 1} UI as completed.`);
        if (!currentChapterText) return; // Should not happen, but safe check

        // Iterate through all characters and mark them as 'correct'
        for (let i = 0; i < currentChapterText.length; i++) {
            if (currentChapterText[i] === P_BREAK_PLACEHOLDER) continue; // Skip placeholders

            const charSpan = document.getElementById(`char-${i}`);
            if (charSpan) {
                // Remove potentially conflicting classes and add 'correct'
                charSpan.classList.remove('incorrect', 'current', 'needs-enter');
                charSpan.classList.add('correct');
            }
        }
        // Ensure the cursor ('current' class) is not shown after marking complete
        const previousChar = sourceTextArea.querySelector('span.current');
        if (previousChar) previousChar.classList.remove('current');

        // Optional: Scroll to the end to show completion visually
        textDisplayArea.scrollTo({ top: textDisplayArea.scrollHeight, behavior: 'auto' }); // Use auto for instant jump
    }

}); // End DOMContentLoaded

